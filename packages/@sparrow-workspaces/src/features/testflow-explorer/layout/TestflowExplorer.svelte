<script lang="ts">
  import { writable } from "svelte/store";
  import {
    SvelteFlow,
    Background,
    type Node,
    type NodeTypes,
    type EdgeTypes,
    useSvelteFlow,
    SvelteFlowProvider,
  } from "@xyflow/svelte";

  import {
    StartBlock,
    RequestBlock,
    RequestBodyTestFlow,
    RunHistory,
    RequestHeaderTestFlow,
    RequestParameterTestFlow,
    RequestNavigatorTestFlow,
    ResponseErrorScreen,
    ResponseStatus,
    ResponseNavigator,
    ResponseBodyNavigator,
    ResponseBody,
    ResponseHeaders,
    TestFlowName,
    SaveTestflow,
    Edge,
  } from "../components";
  import {
    RequestDatasetEnum,
    RequestDataTypeEnum,
    RequestSectionEnum,
    ResponseFormatterEnum,
    ResponseSectionEnum,
    type CollectionDto,
  } from "@sparrow/common/types/workspace";
  import { type Tab } from "@sparrow/common/types/workspace/tab";

  import "@xyflow/svelte/dist/style.css";
  import { onDestroy, onMount } from "svelte";

  import "@xyflow/svelte/dist/style.css";
  import type { Observable } from "rxjs";
  import type { CollectionDocument } from "@app/database/database";
  import {
    TableSidebar,
    TestFlowTourGuide,
  } from "@sparrow/workspaces/components";
  import { PlayFilled, RunIcon, StopFilled } from "@sparrow/library/icons";
  import { Button, Modal, notifications } from "@sparrow/library/ui";
  import { BroomRegular } from "@sparrow/library/icons";
  import { Tooltip } from "@sparrow/library/ui";
  import DeleteNode from "../../../components/delete-node/DeleteNode.svelte";
  import CustomRequest from "../../../components/custom-request-modal/CustomRequest.svelte";
  import { ResponseStatusCode } from "@sparrow/common/enums";
  import type {
    TFDataStoreType,
    TFEdgeHandlerType,
    TFEdgeType,
    TFNodeHandlerType,
    TFNodeStoreType,
    TFNodeType,
  } from "@sparrow/common/types/workspace/testflow";
  import { Events } from "@sparrow/common/enums/mixpanel-events.enum";
  import MixpanelEvent from "@app/utils/mixpanel/MixpanelEvent";
  import { captureEvent } from "@app/utils/posthog/posthogConfig";
  import {
    Debounce,
    handleEventOnOpenDE,
    InitFolderTab,
    InitRequestTab,
    OSDetector,
  } from "@sparrow/common/utils";
  import { stringify, v4 as uuidv4 } from "uuid";
  import {
    currentStep,
    isTestFlowTourGuideOpen,
  } from "../../../stores/guide.tour";
  import { platform } from "@tauri-apps/plugin-os";
  import {
    defaultAutoGeneratedHeaders,
    defaultState,
    defaultRequestData,
  } from "../../../../../@sparrow-common/src/utils/testFlow.helper";
  import SaveNode from "../../../components/save-node-modal/SaveNode.svelte";
  import TestFlowBottomPanel from "../components/test-flow-bottom-panel/TestFlowBottomPanel.svelte";
  import {
    HttpRequestAuthTypeBaseEnum,
    HttpRequestContentTypeBaseEnum,
  } from "@sparrow/common/types/workspace/http-request-base";
  import TestflowDynamicExpression from "../../testflow-dynamic-expressions/layout/TestflowDynamicExpression.svelte";
  // import { isDynamicExpressionModalOpen } from "../store/testflow";
  import { selectedRequestTypes } from "../store/testflow";
  import {
    isDynamicExpressionContent,
    updateDynamicExpressionValue,
  } from "../store/testflow";
  import { WorkspaceRole } from "@sparrow/common/enums";
  import { PlanUpgradeModal } from "@sparrow/common/components";
  import { planInfoByRole } from "@sparrow/common/utils";
  import { TeamRole } from "@sparrow/common/enums";
  import { planContentDisable } from "@sparrow/common/utils";

  // Declaring props for the component
  export let tab: Observable<Partial<Tab>>;
  export let onUpdateNodes;
  export let onUpdateEdges;
  export let collectionList: Observable<CollectionDocument[]>;
  export let onClickRun;
  export let onRunSampleApi;
  export let testflowStore: TFDataStoreType;
  export let toggleHistoryDetails;
  export let toggleHistoryContainer;
  export let environmentVariables;
  export let isTestflowEditable;
  export let onRedrectRequest;
  export let onUpdateTestFlowName;
  export let onUpdateBlockData;
  export let onSaveTestflow;
  export let isWebApp;
  export let deleteNodeResponse;
  export let onClickStop;
  export let onClearTestflow;
  export let isTestFlowEmpty;
  export let onSelectRequest;
  export let userRole;
  export let onUpdateEnvironment;
  export let runSingleNode;
  export let onPreviewExpression;
  export let redirectDocsTestflow: () => void;
  export let handleEventOnClickQuestionMark;
  export let planLimitRunHistoryCount: number = 5;
  export let planLimitTestFlowBlocks: number = 5;
  export let planLimitTestFlows: number = 3;
  export let testflowCount: number = 1;
  export let teamDetails: any;
  export let testflowBlocksPlanModalOpen: boolean = false;
  export let handleRequestOwner: () => void;
  export let handleRedirectToAdminPanel: () => void;
  export let handleContactSales: () => void;
  export let runHistoryPlanModalOpen: boolean = false;
  export let selectiveRunModalOpen: boolean = false;
  export let selectiveRunTestflow: boolean = false;
  export let isGuestUser = false;
  let planContent: any;
  let planContentNonActive: any;

  const checkRequestExistInNode = (_id: string) => {
    let result = false;
    nodes.update((nodes) => {
      for (let index = 0; index < nodes.length; index++) {
        if (nodes[index].id === _id) {
          if (nodes[index]?.data?.requestData?.method) {
            result = true;
            unsavedChangesModal.blockName = nodes[index]?.data
              ?.blockName as string;
            unsavedChangesModal.id = nodes[index].id;
            unsavedChangesModal.requestName =
              nodes[index]?.data?.requestData?.name;
            break;
          }
        }
      }
      return nodes;
    });
    return result;
  };

  const osDetector = new OSDetector();
  let userOS = osDetector.getOS();
  let limitNodesChange = 0;
  let deletedNodeId: string;
  let deleteNodeName: string = "";
  let customRequestName: string = "";
  let customRequestURL: string = "";
  let customHTTPRequestMethod: string = "GET";

  let isDeleteNodeModalOpen = false;
  let isSwitchNodeRequestModalOpen = false;
  let isAddCustomRequestModalOpen = false;

  let divElement: HTMLElement;
  let sampleApiData: TFNodeStoreType;
  let deleteCount = 0; // Variable to store the count of nodes to be deleted
  let selectedTab = "response";
  let requestNavigation = "Request Body";
  let responseNavigation = "Response";
  let nodesValue = 1;
  let selectedNodeName = "";
  let selectedNodeId = "";
  let selectedNode: TFNodeStoreType | undefined;
  let selectedBlock: any | undefined;
  let updateNodeId: string;
  let updateNodeName: string;
  let updateNodeRequestId: string;
  let updateNodeCollectionId: string;
  let updateNodeMethod: string;
  let updateNodeUrl: string;
  let updateNodeFolderId: any;
  let dynamicExpressionDeleteWarning: boolean = false;
  // Flag to control whether nodes are draggable
  let isNodesDraggable = true;
  let isNodeDeletable = false;
  let isEdgeDeletable = false;
  let blockName = `Block ${nodesValue}`;
  // List to store collection documents and filtered collections
  let collectionListDocument: CollectionDocument[];
  let filteredCollections = writable<CollectionDto[]>([]);

  // Writable stores for nodes and edges
  const nodes = writable<Node[]>([]);
  const edges = writable<TFEdgeHandlerType[]>([]);
  setTimeout(() => {}, 1000);

  /**
   * Checks if edges exist for the given node ID.
   * @param _id - Node ID to check for connected edges.
   * @returns True if edges exist, otherwise false.
   */
  const checkIfEdgesExist = (_id: string, _direction = "right") => {
    let edge: TFEdgeHandlerType[] = [];
    edges.subscribe((value) => {
      edge = value;
    })();
    let response = false;
    edge.forEach((it) => {
      if (_direction === "right") {
        if (it.id.replace("xy-edge__", "").split("-")[0] === _id) {
          response = true;
        }
      } else {
        if (it.id.replace("xy-edge__", "").split("-")[1] === _id) {
          response = true;
        }
      }
    });
    return response;
  };

  const createBlankRequestObject = (
    _url: string,
    _method: string,
    _name: string,
  ) => {
    const response: any = {};
    const tempTab = new InitRequestTab("uuid", "uuid").getValue().property
      .request;
    response.url = _url; // getting url from Modal.
    response.method = _method; // getting method from Modal.
    response.name = _name; // getting name from Modal.
    response.queryParams = tempTab?.queryParams;
    response.headers = tempTab?.headers;
    response.autoGeneratedHeaders = tempTab?.autoGeneratedHeaders;
    response.body = tempTab?.body;
    response.body.formdata = {
      text: [
        {
          key: "",
          value: "",
          checked: false,
        },
      ],
      file: [],
    };
    response.auth = tempTab?.auth;
    response.state = tempTab?.state;
    return response;
  };

  const setBodyType = (header: string) => {
    let requestBodyNavigation = RequestDatasetEnum.RAW;
    let requestBodyLanguage = RequestDataTypeEnum.TEXT;
    switch (header) {
      case HttpRequestContentTypeBaseEnum["none"]:
        requestBodyNavigation = RequestDatasetEnum.NONE;
        requestBodyLanguage = RequestDataTypeEnum.TEXT;
        break;
      case HttpRequestContentTypeBaseEnum["application/json"]:
        requestBodyNavigation = RequestDatasetEnum.RAW;
        requestBodyLanguage = RequestDataTypeEnum.JSON;
        break;
      case HttpRequestContentTypeBaseEnum["application/xml"]:
        requestBodyNavigation = RequestDatasetEnum.RAW;
        requestBodyLanguage = RequestDataTypeEnum.XML;
        break;
      case HttpRequestContentTypeBaseEnum["application/javascript"]:
        requestBodyNavigation = RequestDatasetEnum.RAW;
        requestBodyLanguage = RequestDataTypeEnum.JAVASCRIPT;
        break;
      case HttpRequestContentTypeBaseEnum["text/plain"]:
        requestBodyNavigation = RequestDatasetEnum.RAW;
        requestBodyLanguage = RequestDataTypeEnum.TEXT;
        break;
      case HttpRequestContentTypeBaseEnum["text/html"]:
        requestBodyNavigation = RequestDatasetEnum.RAW;
        requestBodyLanguage = RequestDataTypeEnum.HTML;
        break;
      case HttpRequestContentTypeBaseEnum["application/x-www-form-urlencoded"]:
        requestBodyNavigation = RequestDatasetEnum.URLENCODED;
        break;
      case HttpRequestContentTypeBaseEnum["multipart/form-data"]:
        requestBodyNavigation = RequestDatasetEnum.FORMDATA;
        break;
    }
    return { requestBodyLanguage, requestBodyNavigation };
  };

  const setAuthType = (
    auth: HttpRequestAuthTypeBaseEnum,
  ): HttpRequestAuthTypeBaseEnum => {
    let requestAuthNavigation = HttpRequestAuthTypeBaseEnum.NO_AUTH;
    switch (auth) {
      case HttpRequestAuthTypeBaseEnum.NO_AUTH:
        requestAuthNavigation = HttpRequestAuthTypeBaseEnum.NO_AUTH;
        break;
      case HttpRequestAuthTypeBaseEnum.API_KEY:
        requestAuthNavigation = HttpRequestAuthTypeBaseEnum.API_KEY;
        break;
      case HttpRequestAuthTypeBaseEnum.BASIC_AUTH:
        requestAuthNavigation = HttpRequestAuthTypeBaseEnum.BASIC_AUTH;
        break;
      case HttpRequestAuthTypeBaseEnum.BEARER_TOKEN:
        requestAuthNavigation = HttpRequestAuthTypeBaseEnum.BEARER_TOKEN;
        break;
      case HttpRequestAuthTypeBaseEnum.INHERIT_AUTH:
        requestAuthNavigation = HttpRequestAuthTypeBaseEnum.NO_AUTH;
        break;
    }
    return requestAuthNavigation;
  };

  const createCustomRequestObject = async (
    collectionId: string,
    requestId: string,
    folderId: string,
  ) => {
    const response: any = {};
    const tempTab = new InitRequestTab("uuid", "uuid").getValue().property
      .request;
    const data = await onSelectRequest(collectionId, requestId, folderId);
    if (!data) {
      // something went wrong, lets debug.
    }
    if (data?.request?.autoGeneratedHeaders) {
      response.autoGeneratedHeaders = data?.request?.autoGeneratedHeaders;
    } else {
      response.autoGeneratedHeaders = tempTab?.autoGeneratedHeaders;
    }
    if (data?.request?.headers) {
      response.headers = data?.request?.headers;
    } else {
      response.headers = tempTab?.headers;
    }
    if (data?.request?.queryParams) {
      response.queryParams = data?.request?.queryParams;
    } else {
      response.queryParams = tempTab?.queryParams;
    }
    if (data?.request?.body) {
      response.body = data?.request?.body;
    } else {
      response.body = tempTab?.body;
      response.body.formdata = {
        text: [
          {
            key: "",
            value: "",
            checked: false,
          },
        ],
        file: [],
      };
    }
    if (data?.request?.auth) {
      response.auth = data?.request?.auth;
    } else {
      response.auth = tempTab?.auth;
    }
    if (data?.request?.url) {
      response.url = data?.request?.url;
    } else {
      response.url = tempTab?.url;
    }
    if (data?.request?.method) {
      response.method = data?.request?.method;
    } else {
      response.method = tempTab?.method;
    }
    if (data?.name) {
      response.name = data.name;
    } else {
      response.name = "Untitled";
    }
    response.state = tempTab?.state;
    if (data?.request?.selectedRequestBodyType) {
      const bodyType = setBodyType(data?.request?.selectedRequestBodyType);
      if (bodyType?.requestBodyLanguage) {
        response.state.requestBodyLanguage = bodyType.requestBodyLanguage;
      }
      if (bodyType?.requestBodyNavigation) {
        response.state.requestBodyNavigation = bodyType.requestBodyNavigation;
      }
    }
    if (data?.request?.selectedRequestAuthType) {
      const AuthType = setAuthType(data?.request?.selectedRequestAuthType);
      if (AuthType) {
        response.state.requestAuthNavigation = AuthType;
      }
    }
    return response;
  };

  let dynamicExpressionEditorContent = "";
  let dynamicExpressionModal = {};
  let dynamicExpressionPath: string = "";
  let handleOpenCurrentDynamicExpression = (obj) => {
    dynamicExpressionModal = {};
    dynamicExpressionModal = obj;
    dynamicExpressionEditorContent = obj?.source?.content?.slice(4, -4) || "";
    dynamicExpressionPath = obj?.type;
    handleEventOnOpenDE("TestFlowExplorer", obj?.type);
    isDynamicExpressionModalOpen = true;
  };

  const onInsertExpression = (newExpression) => {
    if (dynamicExpressionModal?.source) {
      dynamicExpressionModal.dispatch.dispatch({
        changes: {
          from: dynamicExpressionModal.source.from,
          to: dynamicExpressionModal.source.to,
          insert: "[*$[" + newExpression + "]$*]",
        },
      });
    } else {
      dynamicExpressionModal.dispatch.dispatch({
        changes: {
          from:
            dynamicExpressionModal?.dispatch?.state?.selection?.main?.from || 0,
          to: dynamicExpressionModal?.dispatch?.state?.selection?.main?.to || 0,

          insert: "[*$[" + newExpression + "]$*]",
        },
      });
    }
    isDynamicExpressionModalOpen = false;
  };

  const dfs = (adj: any[], start: number, visited = new Set()) => {
    if (visited.has(start)) return;

    nodes.update((nodes) => {
      for (let i = 0; i < nodes.length; i++) {
        if (Number(nodes[i].id) === start) {
          nodes[i].position = {
            x: nodes[i].position.x + 350,
            y: nodes[i].position.y,
          };
        }
      }
      return nodes;
    });
    visited.add(start);

    for (const neighbor of adj[start]) {
      dfs(adj, neighbor, visited);
    }
  };

  /**
   * Updates the selected API in a specific node.
   * @param id - Node ID.
   * @param name - Name of the API.
   * @param requestId - Request ID.
   * @param collectionId - Collection ID.
   * @param method - Request method (e.g., GET, POST).
   * @param folderId - Folder ID (optional).
   */
  const updateNodeRequest = async (
    id: string,
    name: string,
    requestId: string,
    collectionId: string,
    method: string,
    folderId?: string,
    url?: string,
  ) => {
    let response: any = {};
    if (collectionId) {
      response = await createCustomRequestObject(
        collectionId,
        requestId,
        folderId as string,
      );
    } else {
      // create custom API Request.
      response = await createBlankRequestObject(url as string, method, name);
    }

    nodes.update((_nodes) => {
      const dbNodes = _nodes;
      for (let index = 0; index < dbNodes.length; index++) {
        if (dbNodes[index].id === id) {
          dbNodes[index].data.requestId = requestId;
          dbNodes[index].data.collectionId = collectionId;
          dbNodes[index].data.folderId = folderId ?? "";
          dbNodes[index].data.requestData = response;
          dbNodes[index].data.isDeleted = false;
        }
      }
      return dbNodes;
    });
  };

  const handleUpdateRequestData = async (field: string, value: any) => {
    if (!selectedBlock) {
      console.warn("Invalid block data structure");
      return;
    }

    const updatedBlock = JSON.parse(JSON.stringify(selectedBlock));

    const updateMatchingKeys = (obj: any) => {
      if (typeof obj !== "object" || obj === null) return;

      for (const key in obj) {
        if (key === field) {
          obj[key] = value;
        } else if (typeof obj[key] === "object") {
          updateMatchingKeys(obj[key]);
        }
      }
    };

    updateMatchingKeys(updatedBlock);
    selectedBlock = updatedBlock;

    nodes.update((_nodes) => {
      let dbNodes = [..._nodes];

      for (let i = 0; i < dbNodes.length; i++) {
        if (dbNodes[i].id === updatedBlock.id) {
          // Preserve only the specified keys from the original data
          const preservedKeys: Array<string> = [
            "blocks",
            "collections",
            "connector",
            "onCheckEdges",
            "onClick",
            "onOpenAddCustomRequestModal",
            "onContextMenu",
            "onOpenSaveNodeRequestModal",
            "updateBlockName",
          ];

          const originalData = dbNodes[i].data || {};
          const updatedData = updatedBlock.data || {};

          const preservedData = {};
          for (const key of preservedKeys) {
            if (key in originalData) {
              preservedData[key] = originalData[key];
            }
          }

          dbNodes[i] = {
            ...dbNodes[i],
            ...updatedBlock,
            data: {
              ...updatedData,
              ...preservedData,
            },
          };
        }
      }

      return dbNodes;
    });
  };

  /**
   * Finds the next available node ID.
   * @param list - List of existing nodes.
   * @returns The next available node ID as a string.
   */
  const findNextNodeId = (list: { id: string }[]): string => {
    const isNameAvailable: (proposedName: string) => boolean = (
      proposedName,
    ) => {
      return list.some((element) => {
        return element.id === proposedName;
      });
    };

    for (let i = 1; i < list.length + 10; i++) {
      const proposedName: string = `${i}`;
      if (!isNameAvailable(proposedName)) {
        return proposedName;
      }
    }
    return "";
  };

  // Filter collections based on the current tab's workspace ID
  const collectionsSubscriber = collectionList.subscribe((value) => {
    if (value) {
      collectionListDocument = value?.filter(
        (value) => value.workspaceId === $tab?.path?.workspaceId,
      );
      filteredCollections.set(
        collectionListDocument as unknown as CollectionDto[],
      );
    }
  });

  nodes.subscribe((nodes) => {
    if (nodes?.length > 0) {
      if (!limitNodesChange) {
        limitNodesChange = limitNodesChange + 1;
      }
    }
  });

  let dynamicExpressionDependencyCount = 0;
  /**
   * Opens the delete confirmation modal and sets the ID of the node to be deleted.
   * Also triggers the count of the next node to be deleted.
   *
   * @param id - The ID of the node to be deleted.
   */
  const handleDeleteModal = (id: string) => {
    dynamicExpressionDependencyCount = 0;
    if (!id) return;
    if (id === "1") return;
    isDeleteNodeModalOpen = true;
    deletedNodeId = id;
    let filteredNodes = $nodes.filter(
      (node) => node.id === id,
    ) as unknown as TFNodeHandlerType[];
    deleteNodeName = filteredNodes[0]?.data?.name;

    nodes.update((_nodes) => {
      for (let i = 0; i < _nodes.length; i++) {
        if (_nodes[i].id === id) {
          continue;
        }
        const requestData = JSON.stringify(_nodes[i]?.data?.requestData);
        if (
          requestData.includes(
            "$$" +
              filteredNodes[0]?.data?.requestData?.name?.replace(
                /[^a-zA-Z0-9_]/g,
                "_",
              ),
          ) ||
          requestData.includes(
            "$$" +
              filteredNodes[0]?.data?.blockName?.replace(/[^a-zA-Z0-9_]/g, "_"),
          )
        ) {
          dynamicExpressionDependencyCount =
            dynamicExpressionDependencyCount + 1;
        }
      }
      return _nodes;
    });
  };

  /**
   * @description - Handles the creation of a custom request.
   * the selected HTTP method, request name, and request URL.
   */
  const handleCreateCustomRequest = async (
    _requestName: string,
    _requestMethod: string,
    _requestUrl: string,
  ) => {
    const isExist = await checkRequestExistInNode(customRequestModal.id);

    updateNodeId = customRequestModal.id;
    updateNodeName = _requestName;
    updateNodeRequestId = uuidv4();
    updateNodeCollectionId = "";
    updateNodeMethod = _requestMethod;
    updateNodeFolderId = "";
    updateNodeUrl = _requestUrl;

    if (isExist) {
      isSwitchNodeRequestModalOpen = true;
    } else {
      // populate new api from custom request button
      await updateNodeRequest(
        customRequestModal.id,
        _requestName,
        uuidv4(),
        "",
        _requestMethod,
        "",
        _requestUrl,
      );
    }
    isAddCustomRequestModalOpen = false;
  };

  /**
   * Opens the "Add Custom Request" modal.
   *
   * @param id - The ID associated with the custom request.
   */
  let customRequestModal = {
    id: "",
  };
  let unsavedChangesModal = {
    id: "",
    blockName: "",
    requestName: "",
  };
  const handleOpenAddCustomRequestModal = (_id: string) => {
    isAddCustomRequestModalOpen = true;
    customRequestModal.id = _id;
  };

  /**
   * Opens the "Save Request" modal and update the node's API request.
   **/

  const handleNodeRequestDropdown = async (
    nodeId: string,
    name: string,
    requestId: string,
    collectionId: string,
    method: string,
    folderId: string,
  ) => {
    const isExist = await checkRequestExistInNode(nodeId);

    updateNodeId = nodeId;
    updateNodeName = name;
    updateNodeRequestId = requestId;
    updateNodeCollectionId = collectionId;
    updateNodeMethod = method;
    updateNodeFolderId = folderId;
    updateNodeUrl = "";

    if (isExist) {
      isSwitchNodeRequestModalOpen = true;
    } else {
      // populate existing api for the first time from the api dropdown
      await updateNodeRequest(
        nodeId,
        name,
        requestId,
        collectionId,
        method,
        folderId,
        "",
      );
    }
  };

  /**
   * Creates a new node and connects it to the existing node.
   * @param _id - The ID of the existing node.
   */
  const createNewNode = async (
    _id: string,
    _requestData = undefined,
    _direction = "add-block-after",
  ) => {
    if (!_id) return;
    if ($nodes.length >= planLimitTestFlowBlocks + 1 && !isGuestUser) {
      testflowBlocksPlanModalOpen = true;
      // notifications.error(
      //   `You’ve reached the limit of ${planLimitTestFlowBlocks} Blocks per test flow on your current plan. Upgrade to increase this limit.`,
      // );
      return;
    }
    let requestData;
    if (_requestData) {
      requestData = await createCustomRequestObject(
        _requestData?.collectionId,
        _requestData?.requestId,
        _requestData?.folderId,
      );
    }

    // handles run from from start button click
    if (_id === "0") {
      await onClickRun();
      const startingNode = handleSelectFirstNode();
      if (startingNode) {
        selectNode(startingNode);
      }
      MixpanelEvent(Events.Run_TestFlows);
      return;
    }

    // if (checkIfEdgesExist(_id)) {
    //   return;
    // }

    const newNodeId = findNextNodeId($nodes);

    nodes.update((_nodes: Node[] | any[]) => {
      let nextNodePosition;
      // Find the next node position based on the current node's position
      for (let i = 0; i < _nodes?.length; i++) {
        if (_nodes[i].id === _id) {
          // const additionValue = i === 0 ? 0 : 50;
          nextNodePosition = {
            x: _nodes[i].position.x,
            y: _nodes[i].position.y,
          };
        }
      }
      return [
        ...(_nodes || []),
        {
          id: newNodeId,
          type: "requestBlock",
          data: {
            blockName: `Block ${newNodeId - 1}`,
            blocks: nodes,
            connector: edges,
            onClick: function (_id: string, _options = undefined) {
              createNewNode(_id, _options);
            },
            onCheckEdges: function (_id: string, _direction: string) {
              return checkIfEdgesExist(_id, _direction);
            },
            onContextMenu: function (id: string, _event: string) {
              if (_event === "delete") {
                handleDeleteModal(id);
              } else if (
                _event === "run-from-here" ||
                _event === "run-till-here"
              ) {
                partialRun(id, _event);
              } else if (
                _event === "add-block-before" ||
                _event === "add-block-after"
              ) {
                createNewNode(id, undefined, _event);
              }
            },
            onOpenAddCustomRequestModal: function (id: string) {
              handleOpenAddCustomRequestModal(id);
            },
            onOpenSaveNodeRequestModal: function (
              nodeId: string,
              name: string,
              requestId: string,
              collectionId: string,
              method: string,
              folderId: string,
            ) {
              handleNodeRequestDropdown(
                nodeId,
                name,
                requestId,
                collectionId,
                method,
                folderId,
              );
            },
            updateBlockName: function (_id: string, value: string) {
              handleUpdateBlockName(_id, value);
            },
            collectionId: _requestData?.collectionId,
            folderId: _requestData?.folderId,
            requestId: _requestData?.requestId,
            collections: filteredCollections,
            tabId: $tab.tabId,
            requestData: requestData || createBlankRequestObject("", "", ""),
          },
          position: nextNodePosition,
          deletable: isNodeDeletable,
          draggable: isNodesDraggable, // Disable dragging for this node
        },
      ];
    });

    ////////////////////////////////////////////////////////////
    if (_direction === "add-block-after") {
      /**
       * Future work: Have to handle case if multiple blocks connected to the same node to the right.
       */
      let destinationId: string;
      edges.update((edges) => {
        for (let i = 0; i < edges.length; i++) {
          if (edges[i].source === _id) {
            // afterward block exist
            destinationId = edges[i].target;
            edges[i].target = newNodeId;
            edges[i].id = "xy-edge__" + _id + "-" + newNodeId;
          }
        }
        if (destinationId) {
          // afterward block exist
          return [
            ...edges,
            {
              id: "xy-edge__" + newNodeId + "-" + destinationId,
              source: newNodeId,
              target: destinationId,
              deletable: isEdgeDeletable,
            },
          ];
        } else {
          return [
            ...edges,
            {
              id: "xy-edge__" + _id + "-" + newNodeId,
              source: _id,
              target: newNodeId,
              deletable: isEdgeDeletable,
            },
          ];
        }
      });

      let maxNodeId = 1;
      nodes.update((nodes) => {
        for (let i = 0; i < nodes.length; i++) {
          maxNodeId = Math.max(maxNodeId, Number(nodes[i].id));
        }
        return nodes;
      });
      // Initialize adjacency list
      const graph = Array.from({ length: maxNodeId + 1 }, () => []);
      // Populate adjacency list

      edges.update((edges) => {
        for (let i = 0; i < edges.length; i++) {
          graph[Number(edges[i].source)].push(Number(edges[i].target));
        }
        return edges;
      });
      dfs(graph, Number(newNodeId));
    } else if (_direction === "add-block-before") {
      /**
       * Future work: Have to handle case if multiple blocks connected to the same node to the left.
       */
      let destinationId: any;
      edges.update((edges) => {
        for (let i = 0; i < edges.length; i++) {
          if (edges[i].target === _id) {
            destinationId = edges[i].source;
            edges[i].source = newNodeId;
            edges[i].id = "xy-edge__" + newNodeId + "-" + _id;
          }
        }
        if (destinationId) {
          return [
            ...edges,
            {
              id: "xy-edge__" + destinationId + "-" + newNodeId,
              source: destinationId,
              target: newNodeId,
              deletable: isEdgeDeletable,
            },
          ];
        } else {
          return [
            ...edges,
            {
              id: "xy-edge__" + newNodeId + "-" + _id,
              source: newNodeId,
              target: _id,
              deletable: isEdgeDeletable,
            },
          ];
        }
      });

      let maxNodeId = 1;
      nodes.update((nodes) => {
        for (let i = 0; i < nodes.length; i++) {
          maxNodeId = Math.max(maxNodeId, Number(nodes[i].id));
        }
        return nodes;
      });
      // Initialize adjacency list
      const graph = Array.from({ length: maxNodeId + 1 }, () => []);
      // Populate adjacency list

      edges.update((edges) => {
        for (let i = 0; i < edges.length; i++) {
          graph[Number(edges[i].source)].push(Number(edges[i].target));
        }
        return edges;
      });
      dfs(graph, Number(_id));
      // debugger;
    }
  };

  const handleUpdateBlockName = async (id: string, value: string) => {
    if (!id) return;
    nodes.update((_nodes) => {
      for (let i = 0; i < _nodes.length; i++) {
        if (_nodes[i].id === id) {
          _nodes[i].data.blockName = value;
        }
      }
      return _nodes;
    });
  };

  /**
   * Initializes nodes and edges on component mount.
   */

  let prevTabName = "";
  let prevTabId = "";
  $: {
    if ($tab) {
      if (prevTabId !== $tab?.tabId) {
        (async () => {
          /**
           * @description - Initialize the view model for the new http request tab
           */
          unselectNodes();
          nodes.update((_nodes: Node[]) => {
            const dbNodes = $tab?.property?.testflow?.nodes as TFNodeType[];
            let res = [];
            for (let i = 0; i < dbNodes.length; i++) {
              res.push({
                id: dbNodes[i].id,
                type: dbNodes[i].type,
                data: {
                  blockName: dbNodes[i]?.data?.blockName,
                  blocks: nodes,
                  connector: edges,
                  onClick: function (_id: string, _options = undefined) {
                    createNewNode(_id, _options);
                  },
                  onCheckEdges: function (_id: string, _direction: string) {
                    return checkIfEdgesExist(_id, _direction);
                  },
                  onContextMenu: function (id: string, _event: string) {
                    if (_event === "delete") {
                      handleDeleteModal(id);
                    } else if (
                      _event === "run-from-here" ||
                      _event === "run-till-here"
                    ) {
                      partialRun(id, _event);
                    } else if (
                      _event === "add-block-before" ||
                      _event === "add-block-after"
                    ) {
                      createNewNode(id, undefined, _event);
                    }
                  },
                  onOpenAddCustomRequestModal: function (id: string) {
                    handleOpenAddCustomRequestModal(id);
                  },
                  onOpenSaveNodeRequestModal: function (
                    nodeId: string,
                    name: string,
                    requestId: string,
                    collectionId: string,
                    method: string,
                    folderId: string,
                  ) {
                    handleNodeRequestDropdown(
                      nodeId,
                      name,
                      requestId,
                      collectionId,
                      method,
                      folderId,
                    );
                  },
                  updateBlockName: function (_id: string, value: string) {
                    handleUpdateBlockName(_id, value);
                  },
                  collectionId: dbNodes[i].data?.collectionId,
                  requestId: dbNodes[i].data?.requestId,
                  folderId: dbNodes[i].data?.folderId,
                  requestData: dbNodes[i].data?.requestData,
                  collections: filteredCollections,
                  tabId: $tab.tabId,
                },
                position: {
                  x: dbNodes[i].position.x,
                  y: dbNodes[i].position.y,
                },
                deletable: dbNodes[i].id === "1" ? false : isNodeDeletable,
                draggable: dbNodes[i].id === "1" ? false : isNodesDraggable, // Disable dragging for this node
              });
            }
            return res;
          });
          edges.update((_edges: TFEdgeHandlerType[]) => {
            const dbEdges = $tab?.property?.testflow?.edges as TFEdgeType[];
            let res = [];
            for (let i = 0; i < dbEdges.length; i++) {
              res.push({
                id: dbEdges[i].id,
                source: dbEdges[i].source,
                type: "edge",
                target: dbEdges[i].target,
                deletable: isEdgeDeletable,
                data: {
                  onDeleteEdge: deleteEdges,
                  onCreateNode: createNewNode,
                },
              });
            }
            return res;
          });

          prevTabId = $tab?.tabId;
        })();
      } else if ($tab?.name && prevTabName !== $tab.name) {
        // renameWithEnvironmentList(tab.name);
        prevTabName = $tab.name;
      }
      // findUserRole();
    }
  }

  onMount(() => {
    // Load initial nodes from the tab property
  });

  // Reactive statement to handle selected node updates
  $: {
    if (testflowStore || selectedNodeId) {
      let isIdExist = false;
      testflowStore?.nodes?.forEach((element: TFNodeStoreType) => {
        if (element.id === selectedNodeId) {
          selectedNode = element;
          isIdExist = true;
        }
      });
      if (!isIdExist) {
        selectedNode = undefined;
      }
      if (testflowStore?.history.length > 0) {
        handleTestFlowHistoryLimit();
      }
    }
  }

  /**
   * The node types used in the SvelteFlow graph.
   */
  const nodeTypes = {
    startBlock: StartBlock,
    requestBlock: RequestBlock,
  } as unknown as NodeTypes;

  const edgeTypes = {
    edge: Edge,
  } as unknown as EdgeTypes;

  let isRunButtonEnabled = false;
  // Subscribe to changes in the nodes
  const nodesSubscriber = nodes.subscribe((val: Node[]) => {
    if (val && val.length) {
      onUpdateNodes(val);
    }
    nodesValue = val.length;
    // Find the node where selected is true
    let node = val.find((node: Node) => node.selected === true);

    if (node) {
      selectedBlock = node;
      selectedNodeName = (node?.data?.requestData?.name as string) || "";
      selectedNodeId = node.id;
    } else {
      (selectedNodeName = ""), (selectedNodeId = "");
    }
  });

  let prevEdgeLength = 0;
  // Subscribe to changes in the edges
  const edgesSubscriber = edges.subscribe((val) => {
    isRunButtonEnabled = false;
    if (val) {
      onUpdateEdges(val);
      if (prevEdgeLength !== val.length) {
        edges.update((edges) => {
          val.forEach((edge) => {
            edge.type = "edge";
            edge.data = {
              onDeleteEdge: deleteEdges,
              onCreateNode: createNewNode,
            };
            edge.deletable = isEdgeDeletable;
          });
          return val;
        });
      }
      prevEdgeLength = val.length || 0;
      val.find((edge) => {
        if (edge.source === "1") {
          isRunButtonEnabled = true;
        }
      });
    }
  });

  /**
   * Updates the active tab inside the Request Body section.
   * @param tab - The tab to update.
   * @returns- The updated request navigation.
   */
  const updateActiveTabInsideRequestBody = (tab: string) => {
    if (tab === "Request Body") {
      requestNavigation = "Request Body";
    } else if (tab === "Headers") {
      requestNavigation = "Headers";
    } else {
      requestNavigation = "Parameters";
    }

    return requestNavigation;
  };

  /**
   * Updates the navigation inside the Response section.
   * @param tab - The tab to update.
   * @returns - The updated response navigation.
   */
  function updateResponseNavigation(tab: string) {
    if (tab === "Response") {
      responseNavigation = "Response";
    } else if (tab === "Headers") {
      responseNavigation = "Headers";
    }
    return responseNavigation;
  }

  /**
   * Handles the deletion of a node and its related edges by filtering
   * the `nodes` and `edges` stores, and performs necessary cleanup actions.
   * @param id - The ID of the node to delete.
   */
  const handleDeleteNode = (idToDelete: string) => {
    nodes.update((_nodes) => {
      return _nodes.filter((node) => node.id !== idToDelete);
    });

    edges.update((_edges) => {
      const incomingEdge = _edges.find((edge) => edge.target === idToDelete);
      const outgoingEdge = _edges.find((edge) => edge.source === idToDelete);
      let newEdge = [];
      if (incomingEdge && outgoingEdge) {
        // Reconnect source of incomingEdge to target of outgoingEdge
        newEdge.push({
          id: `xy-edge__${incomingEdge.source}-${outgoingEdge.target}`,
          source: incomingEdge.source,
          target: outgoingEdge.target,
          deletable: isEdgeDeletable,
        });
      }
      const filteredEdges = _edges.filter((edge) => {
        if (edge.source === idToDelete || edge.target === idToDelete) {
          return false;
        }
        return true;
      });
      return [...filteredEdges, ...newEdge];
    });
    deleteNodeResponse($tab.tabId, selectedNodeId);
    unselectNodes();
    isDeleteNodeModalOpen = false;
  };

  /**
   * Unselect all the existing nodes
   */
  const unselectNodes = () => {
    selectedBlock = undefined;
    nodes.update((_nodes: Node[] | any[]) => {
      _nodes.forEach((_nodeItem) => {
        _nodeItem.selected = false;
      });
      return _nodes;
    });
  };

  /**
   * Select all the existing nodes
   */
  const selectNode = (_id: string) => {
    nodes.update((_nodes: Node[] | any[]) => {
      _nodes.forEach((_nodeItem) => {
        if (_nodeItem.id === _id) {
          _nodeItem.selected = true;
        } else {
          _nodeItem.selected = false;
        }
      });
      return _nodes;
    });
  };

  /**
   * This Function will the pass the value of first Node is Connected Target value.
   */
  const handleSelectFirstNode = () => {
    let defaultNode = "2";
    edges.update((_edges) => {
      for (let item = 0; item < _edges.length; item++) {
        if (_edges[item]?.source === "1") {
          defaultNode = _edges[item]?.target;
          break;
        }
      }
      return _edges;
    });
    return defaultNode;
  };

  /**
   * Focuses the div element by calling its focus method.
   */
  const focusDiv = () => {
    divElement.focus();
  };

  /**
   * Handles the drag enter event and updates all nodes to set `parentDrag` to true.
   */
  const handleDragEnter = new Debounce().debounce(() => {
    nodes.update((nodes) => {
      return nodes.map((node, index, array) => ({
        ...node,
        data: {
          ...node.data,
          parentDrag: true,
        },
      }));
    });
  }, 300);

  /**
   * Handles the drag end event with a debounce of 1000 milliseconds
   * and updates all nodes to set `parentDrag` to false.
   */
  const handleDragEnd = new Debounce().debounce(() => {
    nodes.update((nodes) =>
      nodes.map((node, index, array) => ({
        ...node,
        data: {
          ...node.data,
          parentDrag: false,
        },
      })),
    );
  }, 300);

  /**
   * Cleanup function to be called when the component is destroyed.
   * Unsubscribes from `collectionsSubscriber` and invokes the cleanup
   * functions for `nodesSubscriber` and `edgesSubscriber`.
   */
  onDestroy(() => {
    collectionsSubscriber.unsubscribe();
    nodesSubscriber();
    edgesSubscriber();
  });

  onMount(() => {
    setTimeout(() => {
      sampleApiData = onRunSampleApi();
    }, 0);
  });

  const partialRun = async (_id: string, _event: string) => {
    if (!selectiveRunTestflow && !isGuestUser) {
      selectiveRunModalOpen = true;
    }
    if (!testflowStore?.isTestFlowRunning) {
      unselectNodes();
      await onClickRun(_id, _event);
      selectNode(_id);
    }
  };
  let selectedAPI: any;
  let expression: string = "";
  let selectedApiRequestType: any = "";

  const handleAddingNested = (value: string) => {
    if (selectedApiRequestType === "body") {
      expression = expression + value;
    }
  };

  $: {
    if (selectedAPI && selectedApiRequestType) {
      const data: any = selectedAPI?.requestData[selectedApiRequestType];
      if (data && selectedApiRequestType === "body") {
        // selectedRequestTypes.set(data);
      } else if (data && selectedApiRequestType === "headers") {
        // selectedRequestTypes.set(data);
      } else if (data && selectedApiRequestType === "queryParams") {
        // selectedRequestTypes.set(data);
      }
    }
  }

  // const setIsCurrentOpenFalse = () => {
  //   isDynamicExpressionContent.update((items) =>
  //     items.map((item) =>
  //       item.isCurrentOpen ? { ...item, isCurrentOpen: false } : item,
  //     ),
  //   );
  // };

  let isDynamicExpressionModalOpen = false;

  const deleteEdges = (_source: string, _target: string) => {
    edges.update((_edges) => {
      const filteredEdges = _edges.filter((edge) => {
        if (edge.source === _source && edge.target === _target) {
          return false;
        }
        return true;
      });

      return [...filteredEdges];
    });
  };

  const handleEventOnRunBlocks = () => {
    let matchedNames = new Set();
    nodes.update((_nodes) => {
      const regex = /\$\$([a-zA-Z0-9_]+)/g;
      for (let i = 0; i < _nodes.length; i++) {
        const requestData = JSON.stringify(_nodes[i]?.data?.requestData || {});
        let match;
        while ((match = regex.exec(requestData)) !== null) {
          matchedNames.add(match[1]);
        }
      }
      return _nodes;
    });
    const matchedNamesArray = Array.from(matchedNames);
    if (matchedNamesArray.length > 0) {
      captureEvent("send_request_with_expression", {
        component: "TestExplorer",
        blockNames: matchedNamesArray.toString(),
      });
    }
  };

  const handleTestFlowHistoryLimit = () => {
    if (testflowStore?.history && !isGuestUser) {
      const updateHistoryItems = testflowStore.history.slice(
        0,
        planLimitRunHistoryCount,
      );
      testflowStore.history = updateHistoryItems;
    }
  };

  $: {
    if (userRole) {
      planContent = planInfoByRole(userRole);
      planContentNonActive = planContentDisable();
    }
  }
</script>

<div
  class="h-100 d-flex flex-column position-relative"
  on:dragenter={(e) => {
    // Listens item enter.
    e.preventDefault();
    handleDragEnter();
  }}
  on:drop={(e) => {
    // listens item drop.
    e.preventDefault();
    handleDragEnd();
  }}
  on:dragover={(e) => {
    // Necessary to enable dropping.
    e.preventDefault();
  }}
>
  <div class="p-3" style="position:absolute; z-index:3; top:0;">
    <!-- INSERT NAME COMPONENT HERE -->
    <TestFlowName {onUpdateTestFlowName} testFlowName={$tab?.name} />
  </div>
  <div
    class="d-flex justify-content-between position-absolute p-3"
    style="top:0; ;
  right:0;
  z-index:3;"
  >
    <div class="d-flex">
      {#if testflowStore?.isTestFlowRunning}
        <div class="d-flex testing-text-container">
          <div class="loader"></div>
          <p class="testing-txt">Running</p>
        </div>
      {/if}
      <div class="run-btn" style="margin-right: 5px; position:relative;">
        {#if isRunButtonEnabled}
          {#if testflowStore?.isTestFlowRunning}
            <Button
              type="secondary"
              size="medium"
              startIcon={StopFilled}
              title={"Stop Flow"}
              onClick={onClickStop}
            />
          {:else}
            <div id="testflow-run-button">
              <Button
                type="primary"
                size="medium"
                startIcon={PlayFilled}
                title="Run"
                onClick={async () => {
                  unselectNodes();
                  await onClickRun();
                  const startingNode = handleSelectFirstNode();
                  if (startingNode) {
                    selectNode(startingNode);
                  }
                  MixpanelEvent(Events.Run_TestFlows);
                  handleEventOnRunBlocks();
                }}
              />
            </div>
          {/if}
        {/if}

        {#if $isTestFlowTourGuideOpen && $currentStep == 6}
          <div style="position:absolute; top:50px; right:350px">
            <TestFlowTourGuide
              targetIds={["testflow-run-button"]}
              title="Run Your Test Flow"
              description={`Almost there! With your blocks and API in place, go ahead and click ‘Run’ to execute your test flow.`}
              CardNumber={6}
              totalCards={7}
              onNext={async () => {
                currentStep.set(7);
              }}
              onClose={() => {
                isTestFlowTourGuideOpen.set(false);
              }}
            />
          </div>
        {/if}
      </div>
      <div style="margin-right: 5px;">
        <Tooltip title="Clear Response" placement="bottom-center" size="small">
          <Button
            type="secondary"
            size="medium"
            disable={testflowStore?.isTestFlowRunning || isTestFlowEmpty}
            startIcon={BroomRegular}
            onClick={onClearTestflow}
          />
        </Tooltip>
      </div>
      {#if !(userRole === WorkspaceRole.WORKSPACE_VIEWER)}
        <div>
          <SaveTestflow
            isSave={$tab.isSaved}
            {isTestflowEditable}
            {onSaveTestflow}
            testFlowRunning={testflowStore?.isTestFlowRunning}
          />
        </div>
      {/if}
      <div class="position-relative">
        <RunHistory
          bind:runHistoryPlanModalOpen
          bind:planLimitRunHistoryCount
          {testflowStore}
          testflowName={$tab?.name}
          {toggleHistoryDetails}
          {toggleHistoryContainer}
          {isGuestUser}
        />
      </div>
    </div>
  </div>
  <div
    bind:this={divElement}
    tabindex="0"
    on:click={focusDiv}
    style="flex:1; overflow:auto; outline: none; position:realtive;"
    id="testflow-container-main"
  >
    <SvelteFlowProvider>
      <SvelteFlow {nodes} {edges} {nodeTypes} {edgeTypes}>
        <Background
          bgColor={"var(--bg-ds-surface-900)"}
          patternColor={"var(--bg-ds-surface-500)"}
          size={4}
          gap={20}
        />
      </SvelteFlow>
    </SvelteFlowProvider>

    {#if $isTestFlowTourGuideOpen && $currentStep == 3}
      <div style="position:absolute; top:196px; left:370px; z-index:1000;">
        <TestFlowTourGuide
          targetIds={["add-block"]}
          title="Add Your First Block"
          CardNumber={3}
          totalCards={7}
          description={`Welcome to the canvas! Click ‘Add Block’ to start building your flow. You're just a few steps away.`}
          onNext={() => {
            currentStep.set(4);
            createNewNode("1");
          }}
          shouldDelay={true}
          onClose={() => {
            isTestFlowTourGuideOpen.set(false);
          }}
        />
      </div>
    {/if}

    {#if $isTestFlowTourGuideOpen && $currentStep == 4}
      <div style="position:absolute; top:198px; left:685px; z-index:1000;">
        <TestFlowTourGuide
          targetIds={["request-block"]}
          title="Select an API"
          description={`Block added—nice! Now, click the dropdown to select an API. Don’t have one? No worries, a sample API is available for you to use.`}
          CardNumber={4}
          totalCards={7}
          onNext={() => {
            currentStep.set(5);
          }}
          onClose={() => {
            isTestFlowTourGuideOpen.set(false);
          }}
        />
      </div>
    {/if}

    {#if $isTestFlowTourGuideOpen && $currentStep == 5}
      <div style="position:absolute; top:265px; left:680px; z-index:1000;">
        <TestFlowTourGuide
          targetIds={["request-block", "dropdown-request-items"]}
          title="Sample API Ready"
          description={`A ready-to-use sample API is available in the dropdown. Select it to move forward with your test flow setup.`}
          CardNumber={5}
          totalCards={7}
          onNext={() => {
            currentStep.set(6);
          }}
          onClose={() => {
            isTestFlowTourGuideOpen.set(false);
          }}
        />
      </div>
    {/if}
    {#if $isTestFlowTourGuideOpen && $currentStep == 7}
      <div
        style="position:absolute; top:200px; left:{isWebApp
          ? '700px'
          : '700px'};"
      >
        <TestFlowTourGuide
          targetIds={["request-block", "testflow-bottom-panel"]}
          isLastStep={true}
          title="You Did It!"
          description={`Congratulations! Your test flow is running successfully. You can re-run the API at any time to update values as needed.`}
          rightButtonName="Finish"
          CardNumber={7}
          additionTopValue={isWebApp ? -140 : -280}
          additionHeightValue={isWebApp ? 260 : 280}
          totalCards={7}
          onNext={() => {
            currentStep.set(-1);
            isTestFlowTourGuideOpen.set(false);
          }}
          onClose={() => {
            isTestFlowTourGuideOpen.set(false);
          }}
        />
      </div>
    {/if}
  </div>
  <!-- Open the bottom panel when it contains the data -->
  {#if selectedBlock && selectedBlock?.data?.requestId}
    <div style=" background-color: transparent; margin: 0px 13px 12px 13px;">
      <TestFlowBottomPanel
        {selectedBlock}
        {environmentVariables}
        onClose={() => unselectNodes()}
        onRedirect={onRedrectRequest}
        {handleUpdateRequestData}
        {isWebApp}
        onClearResponse={() => {}}
        {userRole}
        {onUpdateEnvironment}
        {runSingleNode}
        {testflowStore}
        {handleOpenCurrentDynamicExpression}
      />
    </div>
  {:else if $isTestFlowTourGuideOpen && $currentStep === 7}
    <div
      style=" background-color: transparent; margin: 0px 13px 12px 13px;"
      id="testflow-bottom-panel"
    >
      <!-- Request Response Nav -->
      <TestFlowBottomPanel
        selectedBlock={{
          data: {
            name: "Sample API",
            method: "GET",
            blockName: "Block 1",
            requestData: {
              name: "Sample API",
              method: "GET",
              state: {
                requestBodyLanguage: RequestDataTypeEnum.TEXT,
                requestBodyNavigation: RequestDatasetEnum.NONE,
                requestAuthNavigation: HttpRequestAuthTypeBaseEnum.NO_AUTH,
                requestNavigation: RequestSectionEnum.PARAMETERS,
                responseNavigation: ResponseSectionEnum.RESPONSE,
                responseBodyLanguage: RequestDataTypeEnum.TEXT,
                responseBodyFormatter: ResponseFormatterEnum.PRETTY,
                requestExtensionNavigation: "",
                requestLeftSplitterWidthPercentage: 50,
                requestRightSplitterWidthPercentage: 50,
                isExposeEditDescription: true,
                isSendRequestInProgress: false,
                isSaveDescriptionInProgress: false,
                isSaveRequestInProgress: false,
                isParameterBulkEditActive: false,
                isHeaderBulkEditActive: false,
                isChatbotActive: false,
                isChatbotSuggestionsActive: true,
                isChatbotGeneratingResponse: false,
                isDocGenerating: false,
                isDocAlreadyGenerated: false,
              },
              url: "https://sparrowapp.dev/api/v1/docs",
              queryParams: [
                {
                  key: "",
                  value: "",
                  checked: false,
                },
              ],
              headers: [
                {
                  key: "",
                  value: "",
                  checked: false,
                },
              ],
            },
          },
        }}
        {environmentVariables}
        onClose={() => unselectNodes()}
        onRedirect={onRedrectRequest}
        {handleUpdateRequestData}
        {isWebApp}
        onClearResponse={() => {}}
        {userRole}
        {onUpdateEnvironment}
      />
    </div>
  {/if}

  <div class="p-3" style="position:absolute; z-index:3; bottom:0; right:0;">
    {#if testflowCount <= planLimitTestFlows || isGuestUser}
      <p
        class="mb-0 pb-0 text-fs-14"
        style="color: var(--text-primary-300); font-weight:500; cursor:pointer;  "
        on:click={() => {
          currentStep.set(1);
          isTestFlowTourGuideOpen.set(true);
        }}
      >
        Need help?
      </p>
    {/if}
  </div>
</div>
<!-- <svelte:window on:keydown={handleKeyPress} /> -->

<Modal
  title={"Insert Dynamic Content"}
  type={"dark"}
  width={"851px"}
  zIndex={1000}
  helpingIcon={true}
  onClickHelpIcon={() => {
    handleEventOnClickQuestionMark();
    redirectDocsTestflow();
  }}
  isOpen={isDynamicExpressionModalOpen}
  handleModalState={() => {
    isDynamicExpressionModalOpen = false;
  }}
>
  <TestflowDynamicExpression
    {dynamicExpressionEditorContent}
    requestApis={$nodes}
    edges={$edges}
    {onInsertExpression}
    {handleAddingNested}
    {selectedBlock}
    {environmentVariables}
    {onPreviewExpression}
    {dynamicExpressionPath}
  />
</Modal>

<Modal
  title={"Delete Block?"}
  type={"dark"}
  width={"540px"}
  zIndex={1000}
  isOpen={isDeleteNodeModalOpen}
  handleModalState={(flag = false) => {
    isDeleteNodeModalOpen = flag;
  }}
>
  <DeleteNode
    {deletedNodeId}
    {deleteNodeName}
    {handleDeleteNode}
    deleteCount={dynamicExpressionDependencyCount}
    handleModalState={(flag = false) => {
      isDeleteNodeModalOpen = flag;
    }}
  />
</Modal>

<Modal
  title={"New Request"}
  type={"dark"}
  width={"540px"}
  zIndex={1000}
  isOpen={isAddCustomRequestModalOpen}
  handleModalState={(flag = false) => {
    isAddCustomRequestModalOpen = flag;
  }}
>
  <CustomRequest
    handleModalState={(flag = false) => {
      isAddCustomRequestModalOpen = flag;
    }}
    {handleCreateCustomRequest}
  />
</Modal>

<Modal
  title={"Unsaved Changes Detected"}
  type={"dark"}
  width={"540px"}
  zIndex={1000}
  isOpen={isSwitchNodeRequestModalOpen}
  handleModalState={(flag = false) => {
    isSwitchNodeRequestModalOpen = flag;
  }}
>
  <SaveNode
    requestName={unsavedChangesModal.requestName}
    blockName={unsavedChangesModal.blockName}
    handleModalState={(flag = false) => {
      isSwitchNodeRequestModalOpen = flag;
    }}
    onSaveRequest={async () => {
      await updateNodeRequest(
        updateNodeId,
        updateNodeName,
        updateNodeRequestId,
        updateNodeCollectionId,
        updateNodeMethod,
        updateNodeFolderId,
        updateNodeUrl,
      );
      isSwitchNodeRequestModalOpen = false;
    }}
  />
</Modal>

<PlanUpgradeModal
  bind:isOpen={testflowBlocksPlanModalOpen}
  title={planContent?.title}
  description={planContent?.description}
  planType="Test flow blocks"
  planLimitValue={planLimitTestFlowBlocks}
  currentPlanValue={$nodes.length - 1}
  isOwner={userRole === TeamRole.TEAM_OWNER || userRole === TeamRole.TEAM_ADMIN
    ? true
    : false}
  {handleContactSales}
  handleSubmitButton={userRole === TeamRole.TEAM_OWNER ||
  userRole === TeamRole.TEAM_ADMIN
    ? handleRedirectToAdminPanel
    : handleRequestOwner}
  userName={teamDetails?.teamName}
  userEmail={teamDetails?.teamOwnerEmail}
  submitButtonName={planContent?.buttonName}
/>

<PlanUpgradeModal
  bind:isOpen={runHistoryPlanModalOpen}
  title={planContent?.title}
  description={planContent?.description}
  planType="Run History"
  planLimitValue={planLimitRunHistoryCount}
  currentPlanValue={testflowStore?.history.length}
  isOwner={userRole === TeamRole.TEAM_OWNER || userRole === TeamRole.TEAM_ADMIN
    ? true
    : false}
  {handleContactSales}
  handleSubmitButton={userRole === TeamRole.TEAM_OWNER ||
  userRole === TeamRole.TEAM_ADMIN
    ? handleRedirectToAdminPanel
    : handleRequestOwner}
  userName={teamDetails?.teamName}
  userEmail={teamDetails?.teamOwnerEmail}
  submitButtonName={planContent?.buttonName}
/>

<PlanUpgradeModal
  bind:isOpen={selectiveRunModalOpen}
  title={planContent?.title}
  description={planContentNonActive?.description}
  planType="Selective Runs"
  activePlan={selectiveRunTestflow ? "active" : "disabled"}
  isOwner={userRole === TeamRole.TEAM_OWNER || userRole === TeamRole.TEAM_ADMIN
    ? true
    : false}
  {handleContactSales}
  handleSubmitButton={userRole === TeamRole.TEAM_OWNER ||
  userRole === TeamRole.TEAM_ADMIN
    ? handleRedirectToAdminPanel
    : handleRequestOwner}
  userName={teamDetails?.teamName}
  userEmail={teamDetails?.teamOwnerEmail}
  submitButtonName={planContent?.buttonName}
/>

<style>
  :global(.svelte-flow__attribution) {
    display: none;
  }

  .loader {
    color: var(--bg-primary-300);
    width: 2px;
    aspect-ratio: 1;
    border-radius: 100%;
    box-shadow:
      9px 0 0 4px,
      18px 0 0 2px,
      27px 0 0 0;
    transform: translateX(-40px);
    animation: l21 0.5s infinite alternate linear;
  }

  @keyframes l21 {
    50% {
      box-shadow:
        9px 0 0 2px,
        18px 0 0 4px,
        27px 0 0 2px;
    }
    100% {
      box-shadow:
        9px 0 0 0,
        18px 0 0 2px,
        27px 0 0 4px;
    }
  }

  .request-rhs-container {
    height: 100%;
    overflow: auto;
    width: calc(100% - 190px);
  }

  .request-container {
    /* background-color: var(--bg-secondary-800); */
    width: 100%;
  }
  .testing-txt {
    color: var(--text-primary-300);
    font-size: 14;
    font-weight: 400;
    align-self: center;
    align-content: center;
    margin-top: 15%;
    margin-right: 6px;
  }
  .testing-text-container {
    align-items: center;
    justify-content: flex-end;
    height: 36px;
    background-color: var(--bg-tertiary-750);
    width: 110px;
    margin-right: 6px;
    padding-left: 12px;
    border-radius: 4px;
  }
</style>
